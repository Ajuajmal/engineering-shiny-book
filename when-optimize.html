<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 15 The Need for Optimization | Engineering Production-Grade Shiny Apps</title>
  <meta name="description" content="Chapter 15 The Need for Optimization | Engineering Production-Grade Shiny Apps" />
  <meta name="generator" content="bookdown 0.18 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 15 The Need for Optimization | Engineering Production-Grade Shiny Apps" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Chapter 15 The Need for Optimization | Engineering Production-Grade Shiny Apps" />
  <meta name="github-repo" content="ThinkR-open/building-shiny-apps-workflow" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 15 The Need for Optimization | Engineering Production-Grade Shiny Apps" />
  
  <meta name="twitter:description" content="Chapter 15 The Need for Optimization | Engineering Production-Grade Shiny Apps" />
  

<meta name="author" content="Colin Fay, Sébastien Rochette, Vincent Guyader, Cervan Girard" />


<meta name="date" content="2020-04-25" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />
<link rel="prev" href="deploy-golem.html"/>
<link rel="next" href="optim-caveat.html"/>
<script src="libs/jquery/jquery.min.js"></script>
<link href="libs/gitbook/css/style.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-clipboard.css" rel="stylesheet" />









<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-149994171-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-149994171-1');
</script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
<link rel="stylesheet" href="css/thinkr.css" type="text/css" />
<link rel="stylesheet" href="css/style_gitbook.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Engineering Production-Grade Shiny Apps</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction</a></li>
<li class="part"><span><b>I Building Successful Shiny Apps</b></span></li>
<li class="chapter" data-level="1" data-path="successfulshinyapp.html"><a href="successfulshinyapp.html"><i class="fa fa-check"></i><b>1</b> About Successful Shiny Apps</a></li>
<li class="chapter" data-level="2" data-path="planning.html"><a href="planning.html"><i class="fa fa-check"></i><b>2</b> Planning Ahead</a></li>
<li class="chapter" data-level="3" data-path="structure.html"><a href="structure.html"><i class="fa fa-check"></i><b>3</b> Structuring your Project</a></li>
<li class="chapter" data-level="4" data-path="golem.html"><a href="golem.html"><i class="fa fa-check"></i><b>4</b> Introduction to <code>{golem}</code></a></li>
<li class="chapter" data-level="5" data-path="workflow.html"><a href="workflow.html"><i class="fa fa-check"></i><b>5</b> The workflow</a></li>
<li class="part"><span><b>II Step 1: Design</b></span></li>
<li class="chapter" data-level="6" data-path="matters.html"><a href="matters.html"><i class="fa fa-check"></i><b>6</b> UX Matters</a></li>
<li class="chapter" data-level="7" data-path="step-design.html"><a href="step-design.html"><i class="fa fa-check"></i><b>7</b> Don’t rush into coding</a></li>
<li class="chapter" data-level="8" data-path="css.html"><a href="css.html"><i class="fa fa-check"></i><b>8</b> A Gentle Introduction to CSS</a></li>
<li class="part"><span><b>III Step 2: Prototype</b></span></li>
<li class="chapter" data-level="9" data-path="setting-up-for-success-with-golem.html"><a href="setting-up-for-success-with-golem.html"><i class="fa fa-check"></i><b>9</b> Setting up for success with <code>{golem}</code></a></li>
<li class="chapter" data-level="10" data-path="stepprotopype.html"><a href="stepprotopype.html"><i class="fa fa-check"></i><b>10</b> Building an “ipsum-app”</a></li>
<li class="part"><span><b>IV Step 3: Build</b></span></li>
<li class="chapter" data-level="11" data-path="stepbuild.html"><a href="stepbuild.html"><i class="fa fa-check"></i><b>11</b> Building app with <code>{golem}</code></a></li>
<li class="part"><span><b>V Step 4: Strengthen</b></span></li>
<li class="chapter" data-level="12" data-path="step-secure.html"><a href="step-secure.html"><i class="fa fa-check"></i><b>12</b> Build yourself a safety net</a></li>
<li class="chapter" data-level="13" data-path="secure.html"><a href="secure.html"><i class="fa fa-check"></i><b>13</b> Version Control</a></li>
<li class="chapter" data-level="14" data-path="deploy-golem.html"><a href="deploy-golem.html"><i class="fa fa-check"></i><b>14</b> Deploy your application</a></li>
<li class="part"><span><b>VI Optimizing</b></span></li>
<li class="chapter" data-level="15" data-path="when-optimize.html"><a href="when-optimize.html"><i class="fa fa-check"></i><b>15</b> The Need for Optimization</a></li>
<li class="chapter" data-level="16" data-path="optim-caveat.html"><a href="optim-caveat.html"><i class="fa fa-check"></i><b>16</b> Common Application Caveats</a></li>
<li class="chapter" data-level="17" data-path="optimizing-shiny-code.html"><a href="optimizing-shiny-code.html"><i class="fa fa-check"></i><b>17</b> Optimizing Shiny Code</a></li>
<li class="chapter" data-level="18" data-path="optimjs.html"><a href="optimjs.html"><i class="fa fa-check"></i><b>18</b> Using JavaScript</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://rtask.thinkr.fr">A book by the ThinkR team</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Engineering Production-Grade Shiny Apps</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="when-optimize" class="section level1">
<h1><span class="header-section-number">Chapter 15</span> The Need for Optimization</h1>
<blockquote>
<p>The most powerful optimization technique in any programmer’s toolbox is to do nothing.</p>
</blockquote>
<!--SHINY.SINGLETON[1efbbb1390b1f2da3adcc5776ac72d01ac3af14a]-->
<style>.right{ text-align: right;}</style>
<!--/SHINY.SINGLETON[1efbbb1390b1f2da3adcc5776ac72d01ac3af14a]-->
<div class="right">
<a href="http://www.catb.org/~esr/writings/taoup/html/">The Art of Unix Programming</a>
</div>
<div id="build-first-then-optimize" class="section level2">
<h2><span class="header-section-number">15.1</span> Build first, then optimize</h2>
<div id="identifying-bottlenecks" class="section level3">
<h3><span class="header-section-number">15.1.1</span> Identifying bottlenecks</h3>
<p>As Donald Knuth puts it <em>“Premature optimization is the root of all evil”</em>.
What does that means?
That focusing on optimizing small portions of your app before making it work fully is the best way to lose time along the way, even more in the context of a production application, where there are deadlines and a limited amount of time to build the application.</p>
<p>Why?
Here is the general idea: in the following schema below, you can make the circles travel to the bottleneck as fast as you want, the circles will still be slowed by the narrow bottleneck, hence you will just be losing time making the circle movement faster, without actually gaining any time on the global performance.
So focus on making the bottleneck larger, before focusing on making the circle travel fast.
When?
Once the application is ready: here in our example, we can only detect the bottleneck once the bottle is actually built, not while we are “building the circle”.</p>
<p><img src="img/bottleneck.png" /></p>
<!--SHINY.SINGLETON[1efbbb1390b1f2da3adcc5776ac72d01ac3af14a]-->
<style>.right{ text-align: right;}</style>
<!--/SHINY.SINGLETON[1efbbb1390b1f2da3adcc5776ac72d01ac3af14a]-->
<div class="right">
<a href="https://commons.wikimedia.org/wiki/File:Effects_of_a_bottleneck_on_virus_populations.png">Adapted from WikiMedia</a>
</div>
<p>This is the very thing you should be optimizing: having faster code anywhere else except this bottleneck will not make your app faster: you will just make your app reach the bottleneck faster, but there will still be this part of your app that slows everything down.
But this is something you might only realize when the app is fully built: pieces might be fast together, but slow when put together.
It is also possible that the test dataset you have been using from the start works just fine, but when you try your app with a bigger, more realistic dataset, the application is actually way slower than it should be.
And, maybe you have been using an example dataset so that you do not have to query the database every time you implement a new feature, but actually the SQL query to the database is very slow.
This is something you will discover only when the application is fully functional, not when building the parts: and realizing that when you only have 5% of the allocated time for this project left on your calendar is not a good surprise.</p>
</div>
<div id="do-you-need-faster-functions" class="section level3">
<h3><span class="header-section-number">15.1.2</span> Do you need faster functions?</h3>
<p>Optimizing an app is a matter of trade-offs: of course, in a perfect world, every piece of the app would be tailored to be fast, easy to maintain, and elegant.
But in the real world, you have deadlines, limited times and resources, and we are all but humans.
That means that at the end of the day, your app will not be completely perfect: a software can <strong>always</strong> be made better.
No piece of code has ever reached complete perfection.</p>
<p>Given that, do you want to spend 5 days out of the 30 you have planned optimizing a function so that it runs in a quarter of a second instead of half a second, then realize the critical bottleneck of your app is actually the SQL query and not the data manipulation?
Of course a function running two times faster is a good thing, but think about it in context: for example, how many times is this function called ?
We can safely bet that if your function is only called once, working on making it twice faster might not be the one function you would want to focus on (well, unless you have unlimited time to work on your project, and in that case lucky you, you can spend a massive amount of time building the perfect software).
On the other hand, the function which is called thousands of time in your application might benefit from being optimized.</p>
<p>And all of this is basic maths.
Let’s assume the following:</p>
<ul>
<li>A current scenario takes 300 seconds to be accomplished on your application</li>
<li>One function <code>A()</code> takes 30 seconds, and it’s called once</li>
<li>One function <code>B()</code> takes 1 second, and it’s called 50 times</li>
</ul>
<p>If you divide the execution time of <code>A()</code> by two, you would be performing a local optimization of 15 seconds, and a global optimization of 15 seconds.
On the other hand, if you divide the execution time of <code>B()</code> by two, you would be performing a local optimization of 0.5 seconds, but a global optimization of 25 seconds.</p>
<p>Again, this kind of optimization is hard to detect until the app is functional.
An optimization of 15 seconds is way greater that an optimization of 0.5 seconds.
Yet you will only realize that once the application is up and running!</p>
</div>
<div id="dont-sacrifice-readability" class="section level3">
<h3><span class="header-section-number">15.1.3</span> Don’t sacrifice readability</h3>
<p>As said in the last section, every piece of code can be rewritten to be faster, either from R to R or using a lower level language: for example C or C++.
You can also rebuild data manipulation code use one package to another, use complex data structures to optimizing memory usage, etc, etc.
But that comes with a price: not keeping thing simple for the sake of local optimization makes maintenance harder, even more if you are using a lesser known language/package.
For example, switching some portions of your code to C++ implies that you might be the only person being able to maintain that specific portion of code, or that your colleague taking over the project will have to spend hours learning the tools you have been building, or the language you have chosen to write your functions with.</p>
<p>Again, optimization is always a matter of trade-off: is the half-second local optimization worth the extra hours you will have to spend correcting bugs when the app will crash and when you will be the only one able to correct it?
Also, are the extra hours/days spent rewriting a working code-base worth the speed gain of 0.5 seconds on one function?</p>
<p>For example, let’s compare both these implementations of the same function, one in R, and one in C++ via <code>{Rcpp}</code> <span class="citation">(Eddelbuettel et al. <a href="#ref-R-Rcpp" role="doc-biblioref">2020</a>)</span>
Of course, the C++ function is faster than the R one—this is the very reason of using C++ with R.</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb200-1"><a href="when-optimize.html#cb200-1"></a><span class="kw">library</span>(<span class="st">&quot;Rcpp&quot;</span>)</span>
<span id="cb200-2"><a href="when-optimize.html#cb200-2"></a><span class="kw">cppFunction</span>(<span class="st">&quot;</span></span>
<span id="cb200-3"><a href="when-optimize.html#cb200-3"></a><span class="st">double mean_cpp(NumericVector x) {</span></span>
<span id="cb200-4"><a href="when-optimize.html#cb200-4"></a><span class="st">  int j;</span></span>
<span id="cb200-5"><a href="when-optimize.html#cb200-5"></a><span class="st">  int size = x.size();</span></span>
<span id="cb200-6"><a href="when-optimize.html#cb200-6"></a><span class="st">  double res = 0;</span></span>
<span id="cb200-7"><a href="when-optimize.html#cb200-7"></a><span class="st">  for (j = 0; j &lt; size; j++){</span></span>
<span id="cb200-8"><a href="when-optimize.html#cb200-8"></a><span class="st">    res = res + x[j];</span></span>
<span id="cb200-9"><a href="when-optimize.html#cb200-9"></a><span class="st">  }</span></span>
<span id="cb200-10"><a href="when-optimize.html#cb200-10"></a><span class="st">  return res / size;</span></span>
<span id="cb200-11"><a href="when-optimize.html#cb200-11"></a><span class="st">}&quot;</span>)</span>
<span id="cb200-12"><a href="when-optimize.html#cb200-12"></a></span>
<span id="cb200-13"><a href="when-optimize.html#cb200-13"></a>benched &lt;-<span class="st"> </span>bench<span class="op">::</span><span class="kw">mark</span>(</span>
<span id="cb200-14"><a href="when-optimize.html#cb200-14"></a>  <span class="dt">cpp =</span> <span class="kw">mean_cpp</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100000</span>),</span>
<span id="cb200-15"><a href="when-optimize.html#cb200-15"></a>  <span class="dt">native =</span> <span class="kw">mean</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100000</span>), </span>
<span id="cb200-16"><a href="when-optimize.html#cb200-16"></a>  <span class="dt">iterations =</span> <span class="dv">1000</span></span>
<span id="cb200-17"><a href="when-optimize.html#cb200-17"></a>)</span>
<span id="cb200-18"><a href="when-optimize.html#cb200-18"></a>benched</span></code></pre></div>
<pre><code>[90m# A tibble: 2 x 6[39m
  expression    min median `itr/sec` mem_alloc `gc/sec`
  [3m[90m&lt;bch:expr&gt;[39m[23m [3m[90m&lt;bch:&gt;[39m[23m [3m[90m&lt;bch:&gt;[39m[23m     [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;bch:byt&gt;[39m[23m    [3m[90m&lt;dbl&gt;[39m[23m
[90m1[39m cpp         145µs  441µs     [4m2[24m554.   783.8KB     33.6
[90m2[39m native      418µs  446µs     [4m2[24m204.    22.7KB      0  </code></pre>
<p>(Note: we will come back to <code>bench::mark</code> later)</p>
<p>Though, how much time gain is worth being sure you will get someone in your team to take over the maintenance if needed?
In other words, given that (in our example), we are gaining around -4.862510^{-6} on the execution time of our function, is it worth switching to C++?
Using external languages or complex data structures implies that from the start, you will need to think about who and how your code base will be maintain over the years.
Chances are that if you plan on using a Shiny application during a span of several years, various R developers will be working on the project, and including C++ code inside your application means that these future developer will either be required to know C++, or they will not be able to maintain this piece of code.</p>
<p>So, to sum up, there are three ways to optimize your application &amp; R code, and the bad news is that you can not optimize for all of them:</p>
<ul>
<li>Optimizing for speed</li>
<li>Optimizing for memory</li>
<li>Optimizing for readability/maintainability</li>
</ul>
<p>Leading a successful project means that you should, as much as possible, find the perfect balance between these three.</p>
</div>
</div>
<div id="tools-for-profiling" class="section level2">
<h2><span class="header-section-number">15.2</span> Tools for profiling</h2>
<div id="profiling-r-code" class="section level3">
<h3><span class="header-section-number">15.2.1</span> Profiling R code</h3>
<div id="identifying-bottlenecks-1" class="section level4">
<h4><span class="header-section-number">15.2.1.1</span> Identifying bottlenecks</h4>
<p>The best way to profile R code is by using the <code>{profvis}</code> <span class="citation">(<span class="citeproc-not-found" data-reference-id="R-profvis"><strong>???</strong></span>)</span> package,<a href="#fn37" class="footnote-ref" id="fnref37"><sup>37</sup></a> a package designed to evaluate how much time each part of a function call take.
With <code>{profvis}</code>, you can spot the bottleneck of your function.
Without an automated tool to do the profiling, the developers would have to profile by guessing, which will, most of the time, come with bad results:</p>
<blockquote>
<p>One of the lessons that the original Unix programmers learned early is that intuition is a poor guide to where the bottlenecks are, even for one who knows the code in question intimately.</p>
</blockquote>
<!--SHINY.SINGLETON[1efbbb1390b1f2da3adcc5776ac72d01ac3af14a]-->
<style>.right{ text-align: right;}</style>
<!--/SHINY.SINGLETON[1efbbb1390b1f2da3adcc5776ac72d01ac3af14a]-->
<div class="right">
<a href="http://www.catb.org/~esr/writings/taoup/html/ch12s02.html">The Art of Unix Programming</a>
</div>
<p>Instead of guessing, it is safe bet to go for a tool like <code>{profvis}</code>, which allows to have a detailed view of what takes a long time to run in your R code.</p>
<p>Using this package is quite straightforward: put the code you want to benchmark inside the <code>profvis()</code> function,<a href="#fn38" class="footnote-ref" id="fnref38"><sup>38</sup></a> wait for the code to run, and… that is it, you now have an analysis of your code running time.</p>
<p>Here is an example with 3 nested functions, <code>top()</code>, <code>middle()</code> and <code>bottom()</code>, where <code>top()</code> calls <code>middle()</code> which calls <code>bottom()</code>:</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb202-1"><a href="when-optimize.html#cb202-1"></a><span class="kw">library</span>(profvis)</span>
<span id="cb202-2"><a href="when-optimize.html#cb202-2"></a>top &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb202-3"><a href="when-optimize.html#cb202-3"></a>  <span class="co"># We use profvis::pause() because Sys.sleep() doesn&#39;t </span></span>
<span id="cb202-4"><a href="when-optimize.html#cb202-4"></a>  <span class="co"># show in the flame graph</span></span>
<span id="cb202-5"><a href="when-optimize.html#cb202-5"></a>  <span class="kw">pause</span>(<span class="fl">0.1</span>)</span>
<span id="cb202-6"><a href="when-optimize.html#cb202-6"></a>  <span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="cf">function</span>(x){</span>
<span id="cb202-7"><a href="when-optimize.html#cb202-7"></a>    x <span class="op">*</span><span class="st"> </span><span class="dv">10</span></span>
<span id="cb202-8"><a href="when-optimize.html#cb202-8"></a>  })</span>
<span id="cb202-9"><a href="when-optimize.html#cb202-9"></a>  <span class="kw">middle</span>()</span>
<span id="cb202-10"><a href="when-optimize.html#cb202-10"></a>}</span>
<span id="cb202-11"><a href="when-optimize.html#cb202-11"></a></span>
<span id="cb202-12"><a href="when-optimize.html#cb202-12"></a>middle &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb202-13"><a href="when-optimize.html#cb202-13"></a>  <span class="kw">pause</span>(<span class="fl">0.2</span>)</span>
<span id="cb202-14"><a href="when-optimize.html#cb202-14"></a>  <span class="fl">1e4</span> <span class="op">*</span><span class="st"> </span><span class="dv">9</span></span>
<span id="cb202-15"><a href="when-optimize.html#cb202-15"></a>  <span class="kw">bottom_a</span>()</span>
<span id="cb202-16"><a href="when-optimize.html#cb202-16"></a>  <span class="kw">bottom_b</span>()</span>
<span id="cb202-17"><a href="when-optimize.html#cb202-17"></a>}</span>
<span id="cb202-18"><a href="when-optimize.html#cb202-18"></a></span>
<span id="cb202-19"><a href="when-optimize.html#cb202-19"></a>bottom_a &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb202-20"><a href="when-optimize.html#cb202-20"></a>  <span class="kw">pause</span>(<span class="fl">0.5</span>)</span>
<span id="cb202-21"><a href="when-optimize.html#cb202-21"></a>  <span class="kw">print</span>(<span class="st">&quot;hey&quot;</span>)</span>
<span id="cb202-22"><a href="when-optimize.html#cb202-22"></a>}</span>
<span id="cb202-23"><a href="when-optimize.html#cb202-23"></a>bottom_b &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb202-24"><a href="when-optimize.html#cb202-24"></a>  <span class="kw">pause</span>(<span class="dv">2</span>)</span>
<span id="cb202-25"><a href="when-optimize.html#cb202-25"></a>  <span class="kw">print</span>(<span class="st">&quot;hey&quot;</span>)</span>
<span id="cb202-26"><a href="when-optimize.html#cb202-26"></a>}</span>
<span id="cb202-27"><a href="when-optimize.html#cb202-27"></a><span class="kw">profvis</span>({</span>
<span id="cb202-28"><a href="when-optimize.html#cb202-28"></a>  <span class="kw">top</span>()</span>
<span id="cb202-29"><a href="when-optimize.html#cb202-29"></a>})</span></code></pre></div>
<p>What you see now is what is called a <code>flame graph</code>: it is a detailed timing of how your function has run, with a clear decomposition of the call stack.
What you see on top window is the expression evaluated, and on the bottom a detail of the call stack, with what looks like a little bit like a Gantt diagram.
This result reads as such: the wider the function call, the more time it has taken R to computer this piece of code.
On the very bottom, the “top” function (i.e. the function which is directly called in the console), and the more you go up, the more you enter the nested function calls.</p>
<p>Here is how to read this graph:</p>
<ul>
<li><p>On the x axis, the time spent computing the function.
Our <code>top()</code> function being the only one executed, it takes the whole record time.</p></li>
<li><p>Then, the second level is the first level of what is called inside <code>top()</code>: first, the function pauses, then it does a series of call to <code>FUN</code> (which is the internal anonymous function from <code>lapply()</code>), then calls the <code>middle()</code> function, which spans from around 100 ms to the end of the call.
Then, a detail of <code>middle()</code>, which calls <code>bottom_a()</code> and <code>bottom_b()</code>, which each <code>pause()</code> for a given amount of time.</p></li>
</ul>
<p><img src="img/profviz_flame.png" /></p>
<p>If you click on the “Data” tab, you will also find another view of the <code>flame graph</code>, where you can read the hierarchy of calls and the time and memory spent on each function call:</p>
<p><img src="img/profviz_data.png" /></p>
<p>If you are working on profiling the memory usage, you can also use the <code>{profmem}</code> <span class="citation">(<span class="citeproc-not-found" data-reference-id="R-profmem"><strong>???</strong></span>)</span> package which, instead of focusing on execution time, will record the memory usage of calls.</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb203-1"><a href="when-optimize.html#cb203-1"></a><span class="kw">library</span>(profmem)</span>
<span id="cb203-2"><a href="when-optimize.html#cb203-2"></a>p &lt;-<span class="st"> </span><span class="kw">profmem</span>({</span>
<span id="cb203-3"><a href="when-optimize.html#cb203-3"></a>  x &lt;-<span class="st"> </span><span class="kw">raw</span>(<span class="dv">1000</span>)</span>
<span id="cb203-4"><a href="when-optimize.html#cb203-4"></a>  A &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="dv">100</span>), <span class="dt">ncol =</span> <span class="dv">10</span>)</span>
<span id="cb203-5"><a href="when-optimize.html#cb203-5"></a>})</span>
<span id="cb203-6"><a href="when-optimize.html#cb203-6"></a>p</span></code></pre></div>
<pre><code>Rprofmem memory profiling of:
{
    x &lt;- raw(1000)
    A &lt;- matrix(rnorm(100), ncol = 10)
}

Memory allocations:
       what bytes               calls
1     alloc   256          &lt;internal&gt;
2     alloc   488          &lt;internal&gt;
3     alloc   488          &lt;internal&gt;
4     alloc  1072          &lt;internal&gt;
5     alloc  1048               raw()
6     alloc   272            matrix()
7     alloc   560            matrix()
8     alloc   552            matrix()
9     alloc  1072            matrix()
10    alloc   848 matrix() -&gt; rnorm()
11    alloc  2552 matrix() -&gt; rnorm()
12    alloc   848            matrix()
13    alloc   528          &lt;internal&gt;
14    alloc  1648          &lt;internal&gt;
15    alloc  1648          &lt;internal&gt;
16    alloc  1072          &lt;internal&gt;
17    alloc   256          &lt;internal&gt;
18    alloc   456          &lt;internal&gt;
19    alloc   216          &lt;internal&gt;
20    alloc   256          &lt;internal&gt;
total       16136                    </code></pre>
<p>You can also get the total allocated memory with:</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb205-1"><a href="when-optimize.html#cb205-1"></a><span class="kw">total</span>(p)</span></code></pre></div>
<pre><code>[1] 16136</code></pre>
<p>And extract specific values based on the memory allocation:</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb207-1"><a href="when-optimize.html#cb207-1"></a>p2 &lt;-<span class="st"> </span><span class="kw">subset</span>(p, bytes <span class="op">&gt;</span><span class="st"> </span><span class="dv">1000</span>)</span>
<span id="cb207-2"><a href="when-optimize.html#cb207-2"></a><span class="kw">print</span>(p2)</span></code></pre></div>
<pre><code>Rprofmem memory profiling of:
{
    x &lt;- raw(1000)
    A &lt;- matrix(rnorm(100), ncol = 10)
}

Memory allocations:
       what bytes               calls
4     alloc  1072          &lt;internal&gt;
5     alloc  1048               raw()
9     alloc  1072            matrix()
11    alloc  2552 matrix() -&gt; rnorm()
14    alloc  1648          &lt;internal&gt;
15    alloc  1648          &lt;internal&gt;
16    alloc  1072          &lt;internal&gt;
total       10112                    </code></pre>
<p>(Example extracted from <code>{profmem}</code> help page).</p>
<p>Here it is, now you have a tool to identify bottlenecks!</p>
</div>
<div id="benchmarking-r-code" class="section level4">
<h4><span class="header-section-number">15.2.1.2</span> Benchmarking R Code</h4>
<p>Identifying bottlenecks is a start, but what to do now?
In the next chapter about optimization, we will dive deeper into common strategies for optimizing R &amp; Shiny code.
But before that, remember this rule: <strong>never start optimizing if you can not benchmark this optimization</strong>.
Why?
Because developers are not perfect at identifying bottlenecks and estimating if something is faster or not, and some optimization methods might lead to slower code.
Of course, most of the time they will not, but in some cases adopting optimization methods leads to writing slower code, because we have missed a bottleneck in our new code.
And of course, without a clear documentation of what we are doing, we will be missing it, relying only on our intuition as an rough guess of speed gain.</p>
<p>In other words, if you want to be sure that you are actually optimizing, be sure that you have a basis to compare with.</p>
<p>How to do that?
One thing that can be done is to keep an RMarkdown file with your starting point: use this notebook to keep track of what you are doing, by noting where you are starting from (i.e, what’s the original function you want to optimize), and compare it with the new one.
By using an Rmd, you can document the strategies you have been using to optimize the code, e.g: “switched from for loop to vectorize function”, “changed from x to y”, etc.
This will also be helpful for the future: either for you in other projects (you can get back to this document), or for other developers, as it will explain why specific decisions have been made.</p>
<p>To do the timing computation, you can use the <code>{bench}</code> <span class="citation">(<span class="citeproc-not-found" data-reference-id="R-bench"><strong>???</strong></span>)</span> package, which compares the execution time (and other metrics) of two functions.
This function takes a series of named elements, each containing an R expression that will be timed.
Note that by default, the <code>mark()</code> function compares the output of each function,</p>
<p>Once the timing is done, you will get a data.frame with various metrics about the benchmark.</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb209-1"><a href="when-optimize.html#cb209-1"></a>x &lt;-<span class="st"> </span><span class="cf">function</span>(size){</span>
<span id="cb209-2"><a href="when-optimize.html#cb209-2"></a>  res &lt;-<span class="st"> </span><span class="kw">numeric</span>(size)</span>
<span id="cb209-3"><a href="when-optimize.html#cb209-3"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>size){</span>
<span id="cb209-4"><a href="when-optimize.html#cb209-4"></a>    res[i] &lt;-<span class="st"> </span>i <span class="op">*</span><span class="st"> </span><span class="dv">10</span></span>
<span id="cb209-5"><a href="when-optimize.html#cb209-5"></a>  }</span>
<span id="cb209-6"><a href="when-optimize.html#cb209-6"></a>  <span class="kw">return</span>(res)</span>
<span id="cb209-7"><a href="when-optimize.html#cb209-7"></a>}</span>
<span id="cb209-8"><a href="when-optimize.html#cb209-8"></a>y &lt;-<span class="st"> </span><span class="cf">function</span>(size){</span>
<span id="cb209-9"><a href="when-optimize.html#cb209-9"></a>  (<span class="dv">1</span><span class="op">:</span>size) <span class="op">*</span><span class="st"> </span><span class="dv">10</span></span>
<span id="cb209-10"><a href="when-optimize.html#cb209-10"></a>}</span>
<span id="cb209-11"><a href="when-optimize.html#cb209-11"></a>res &lt;-<span class="st"> </span>bench<span class="op">::</span><span class="kw">mark</span>(</span>
<span id="cb209-12"><a href="when-optimize.html#cb209-12"></a>  <span class="st">`</span><span class="dt">for</span><span class="st">`</span> =<span class="st"> </span><span class="kw">x</span>(<span class="dv">1000</span>), </span>
<span id="cb209-13"><a href="when-optimize.html#cb209-13"></a>  <span class="dt">vectorized =</span> <span class="kw">y</span>(<span class="dv">1000</span>), </span>
<span id="cb209-14"><a href="when-optimize.html#cb209-14"></a>  <span class="dt">iterations =</span> <span class="dv">1000</span></span>
<span id="cb209-15"><a href="when-optimize.html#cb209-15"></a>)</span>
<span id="cb209-16"><a href="when-optimize.html#cb209-16"></a>res</span></code></pre></div>
<pre><code>[90m# A tibble: 2 x 6[39m
  expression     min  median `itr/sec` mem_alloc
  [3m[90m&lt;bch:expr&gt;[39m[23m [3m[90m&lt;bch:t&gt;[39m[23m [3m[90m&lt;bch:t&gt;[39m[23m     [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;bch:byt&gt;[39m[23m
[90m1[39m for        52.74µs 53.67µs    [4m1[24m[4m8[24m322.    30.4KB
[90m2[39m vectorized  4.22µs  4.74µs   [4m1[24m[4m3[24m[4m2[24m285.    11.8KB
[90m# … with 1 more variable: `gc/sec` [3m[90m&lt;dbl&gt;[90m[23m[39m</code></pre>
<p>Here, we have an empiric evidence that one code is faster than the other: by benchmarking the speed of our code, we are able to determine which function is the fastest.</p>
<p>If you want a graphical analysis, <code>{bench}</code> comes with an <code>autoplot</code> method for <code>{ggplot2}</code> <span class="citation">(<span class="citeproc-not-found" data-reference-id="R-ggplot2"><strong>???</strong></span>)</span>:</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb211-1"><a href="when-optimize.html#cb211-1"></a>ggplot2<span class="op">::</span><span class="kw">autoplot</span>(res)</span></code></pre></div>
<p><img src="engineering-production-grade-shiny-apps_files/figure-html/15-when-optimize-7-1.png" width="672" /></p>
<p>And, bonus point, <code>{bench}</code> takes time to check that the two outputs are the same, so that you are sure you are comparing the very same thing, which is another crucial aspect of benchmarking: be sure you are not comparing apple with oranges!</p>
</div>
</div>
<div id="profiling-shiny" class="section level3">
<h3><span class="header-section-number">15.2.2</span> Profiling Shiny</h3>
<p>You can profile Shiny application using the <code>{profvis}</code> package, just as any other piece of R code.
The only thing to note if you want to use this function on an app built with <code>{golem}</code> <span class="citation">(<span class="citeproc-not-found" data-reference-id="R-golem"><strong>???</strong></span>)</span>, you will have to wrap the <code>run_app()</code> function in a <code>print()</code> function.
Long story short, what make the app run is not the function itself, but the printing of the function, so the object returned by <code>run_app()</code> itself can not be profiled.
See the discussion on this <a href="https://github.com/ThinkR-open/golem/issues/146">issue on {golem}</a> to learn more about this.</p>
<p>One other thing that can be optimized when it comes to the user interface is the webpage rendering performance.
To do that, we can use standard web development tools: as said several times, a Shiny application IS a web application, so tools that are language agnostic will work with Shiny.
There are thousands of tools available to do exactly that, and going through all of them would probably not make a lot of sense.</p>
<p>So, let’s focus on getting started with a basic but powerful tool, that comes for free inside your browser: <a href="https://developers.google.com/web/tools/lighthouse">Google Lighthouse</a>, one of the famous tool for profiling web pages, and which is bundled into recent versions of Google Chrome.
The nice thing is that this tool not only cover what you see (i.e. not only what you are actually rendering on your personal computer), but can also audits your app with various configuration, notably on mobile, with low bandwidth and/or mimicking 3G connection.
being able to perform audit of our application as seen on a mobile device is a real strength: we are developing application on our computer, and might not be regularly checking how our application is performing on a mobile.
Yet a large portion of the web navigation is performed on a mobile or table.
Already in 2016, Google <a href="https://www.thinkwithgoogle.com/data/web-traffic-from-smartphones-and-tablets/">wrote</a> that “<em>More than half of all web traffic now comes from smartphones and tablets</em>”.
Knowing the exact number of visitors that browse through mobile is hard: the web is vast, and not all website record the traffic they receive.
Yet many, if not all, studies around how the web is browsed are reporting the same results: more traffic is performed via mobile than via computer.<a href="#fn39" class="footnote-ref" id="fnref39"><sup>39</sup></a></p>
<p>And, the pro of running it in your browser is that it can perform the analysis on locally deployed applications: in other word, you can launch your Shiny application in your R console, open the app in Google Chrome, and run the audit.
A lot of online services needs an URL to do the audit!</p>
<p>Each result from the audit comes with a series of advises and changes you can make on your application to make it better, with links to know more about the specific issue.</p>
<p>And of course, last but not least, you also got the results of the metrics you have “passed”, and it is always a good mood booster to see our app passing some audited points!</p>
<p>Here is a quick introduction to this tool:</p>
<ul>
<li>Open Chrome in incognito mode, so that the page performance is not influenced by any of the installed extensions in your Google Chrome</li>
<li>Open your developer console, either by going to View &gt; Developer &gt; Developer tools, by doing right click &gt; Inspect, or with the keyboard shortcut ctrl/cmd + alt + I</li>
<li>Go to the “Audit” tab</li>
<li>Configure your report (or leave the default)</li>
<li>Click on “Generate Report”</li>
</ul>
<p>Note that you can also install a command line tool with <code>npm install -g lighthouse</code>,<a href="#fn40" class="footnote-ref" id="fnref40"><sup>40</sup></a> then run <code>lighthouse http://urlto.audit</code>: it will produce either a JSON (if asked) or an HTML report (the default).</p>
<p><img src="img/lighthouse-audit.png" /></p>
<p>Google Lighthouse is computing a series of analysis about your webpage.</p>
<p><img src="img/lighthouse-audit-results.png" /></p>
<p>Once the audit is finished, you have some basic but useful indications about your application:</p>
<ul>
<li><p>Performance. This metric mostly analyzes the rendering time of the page: for example how many time does it take to load the app in full, that is to say how many time it takes from the first byte received to the app being fully ready to be used, the time between the very first call to the server and the very first response, etc.
With <code>{shiny}</code> <span class="citation">(<span class="citeproc-not-found" data-reference-id="R-shiny"><strong>???</strong></span>)</span>, you will probably get low performance here, notably due to the fact that <code>{shiny}</code> is serving external dependencies that you might not be able to control.
For example, the report from <code>{hexmake}</code> <span class="citation">(<span class="citeproc-not-found" data-reference-id="R-hexmake"><strong>???</strong></span>)</span> suggests to “Eliminate render-blocking resources”, and most of them are not controlled by the shiny developer: they come bundled with <code>shiny::fluidPage</code> itself.</p></li>
<li><p>Accessibility. Google Lighthouse performs a series of tests about accessibility (see our chapter about accessibility for more information).</p></li>
<li><p>Best practices bundles a list of “misc” best practices around web applications.</p></li>
<li><p>SEO: search engine optimization, or how will your app perform when it comes to search engine indexation.</p></li>
<li><p>Progressive Web App (PWA): a PWA is an app that can run on any device, <em>" reaching anyone, anywhere, on any device with a single codebase"</em>.
Google audit your application to see if your application fits with this idea.</p></li>
</ul>
<p>Profiling web page is a wide topic and a lot of things can be done to enhance the global page performance.
That being said, if you have a limited time to invest in optimizing the front-end performance of the application, Google Lighthouse is a perfect tool, and can be your go-to audit tool for your application.</p>
<p>And if you want to do if from R, the npm lighthouse module allows to output the audit in JSON, which can then be brought back to R!</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb212-1"><a href="when-optimize.html#cb212-1"></a><span class="ex">lighthouse</span> --output json --output-path data-raw/output.json http://localhost:2811</span></code></pre></div>
<p>Then, being a JSON file, you can call if from R:</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb213-1"><a href="when-optimize.html#cb213-1"></a>lighthouse_report &lt;-<span class="st"> </span>jsonlite<span class="op">::</span><span class="kw">read_json</span>(<span class="st">&quot;data-raw/output.json&quot;</span>)</span>
<span id="cb213-2"><a href="when-optimize.html#cb213-2"></a>lighthouse_report<span class="op">$</span>audits<span class="op">$</span><span class="st">`</span><span class="dt">speed-index</span><span class="st">`</span></span></code></pre></div>
<pre><code>$id
[1] &quot;speed-index&quot;

$title
[1] &quot;Speed Index&quot;

$description
[1] &quot;Speed Index shows how quickly the contents of a page are visibly populated. [Learn more](https://web.dev/speed-index).&quot;

$score
[1] 0.56

$scoreDisplayMode
[1] &quot;numeric&quot;

$numericValue
[1] 5439

$displayValue
[1] &quot;5.4 s&quot;</code></pre>
<p>Google Lighthouse also comes with a continuous integration tool, so that you can use it as a regression testing tool for your application.
To know more, feel free to read the <a href="https://github.com/GoogleChrome/lighthouse-ci/blob/master/docs/getting-started.md">documentation</a>!</p>
</div>
<div id="more-resources-about-web-page-performance" class="section level3">
<h3><span class="header-section-number">15.2.3</span> More resources about web page performance</h3>
<ul>
<li><p><a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters">Why Performance Matters - Google Web Fundamentals</a></p></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/Performance">Web Performance - Mozilla Web Docs</a></p></li>
</ul>

</div>
</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-R-Rcpp">
<p>Eddelbuettel, Dirk, Romain Francois, JJ Allaire, Kevin Ushey, Qiang Kou, Nathan Russell, Douglas Bates, and John Chambers. 2020. <em>Rcpp: Seamless R and C++ Integration</em>. <a href="https://CRAN.R-project.org/package=Rcpp">https://CRAN.R-project.org/package=Rcpp</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="37">
<li id="fn37"><p><code>{utils}</code> also comes with a function call <code>Rprof()</code>, but we will not be examining this one here, as <code>{profvis}</code> provides a more user-friendly and enhanced interface to this profiling function.<a href="when-optimize.html#fnref37" class="footnote-back">↩︎</a></p></li>
<li id="fn38"><p>Do not forget to add <code>{}</code> inside <code>profvis({})</code> if you want to write several lines of code.<a href="when-optimize.html#fnref38" class="footnote-back">↩︎</a></p></li>
<li id="fn39"><p><a href="https://www.broadbandsearch.net/blog/mobile-desktop-internet-usage-statistics">broadbandsearch</a> for example, reports a 53.3% share for mobile browsing.<a href="when-optimize.html#fnref39" class="footnote-back">↩︎</a></p></li>
<li id="fn40"><p>Being a NodeJS application, you will need to have NodeJS installed on your machine.<a href="when-optimize.html#fnref40" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
<hr/>
<footer>
<a href="rtask.thinkr.fr"><img src="img/logo400_129.png" alt="ThinkR Website"/></a>
</footer>
            </section>

          </div>
        </div>
      </div>
<a href="deploy-golem.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="optim-caveat.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook/js/app.min.js"></script>
<script src="libs/gitbook/js/lunr.js"></script>
<script src="libs/gitbook/js/clipboard.min.js"></script>
<script src="libs/gitbook/js/plugin-search.js"></script>
<script src="libs/gitbook/js/plugin-sharing.js"></script>
<script src="libs/gitbook/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook/js/plugin-bookdown.js"></script>
<script src="libs/gitbook/js/jquery.highlight.js"></script>
<script src="libs/gitbook/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/ThinkR-open/building-shiny-apps-workflow/edit/master/15-when_optimize.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "none"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
