[
["index.html", "Building Big Shiny Apps - A Workflow Chapter 1 Motivation", " Building Big Shiny Apps - A Workflow Colin Fay 2019-01-27 Chapter 1 Motivation The idea behind this book is not to talk about how to deploy and scale, but about the process of building the app. Why? Lots of blog posts and books talk about putting apps in production. Very few talks about working on building these apps. This is why I choose to talk about the process, workflow, and tools we use at ThinkR when building big Shiny Apps. So, to sum up, we’ll not talk about what to do when the app is ready, we’ll talk about how to make it ready. "],
["bigshinyapp.html", "Chapter 2 About Big Shiny Apps", " Chapter 2 About Big Shiny Apps If you’re reading this page, chances are you already know what a Shiny App is — a web application that communicates with R, built in R, and working with R. Almost anybody can create a prototype for a small data product in a matter of hours. And no knowledge of HTML, CSS or JavaScript is required, making it really easy to use — you can rapidly create a POC. But what to do now you want to build a big Shiny App? What’s a big Shiny App? Well, first, one that includes several thousand lines of code (R and others). It’s also one that is potentially developed by several coders, working on the same application at the same time. It’s an application where scaling matters. Maintainability and ease of upgrading are important. In many cases, Shiny Apps in production are not used by “tech literate” people. People rely on this application for making real-world decisions, with real consequences. "],
["challenges.html", "Chapter 3 Challenges 3.1 Finding a good UI (and stick with it) 3.2 Working as a team", " Chapter 3 Challenges 3.1 Finding a good UI (and stick with it) Choosing a UI is hard — we have a natural tendency, as coders, to be focused on the backend, i.e the algorithmic part of the application. But let’s state the truth: no matter how complex and innovative your backend can be, your application is bad is your UI is bad. That’s the hard truth. If people can’t understand how to use your application, your application doesn’t work. No matter how incredible the backend is. Try to find a simple, and efficient UI. One that people can understand and use in a matter of seconds. Don’t implement features or visual elements that are not actually needed, just “in case”. And spend time working on that UI, really thinking about what visual elements you are implementing. 3.2 Working as a team Big Shiny Apps usually means that several peoples will work on the application. For example, at ThinkR, 3 to 4 people usually work on the application. So, how do we organize that? 3.2.1 From the tools point of view: Use version control (not sure I have to expand on that topic ;) ) Think of your shiny app as a tree, and divide it as much as possible into little pieces. Then, create one Shiny module by piece. This allows you to split the work, and also to have smaller files — it’s easier to work on 20 files of 200 lines than on one big app.R file. 3.2.2 From the organisational point of view Define one person in charge of having the big picture of the app. This person will kick off the project, and write the skeleton of the app, with the good modules and files structure. This person will also be in charge of accepting new merge requests from other developers, and to orchestrate the master and dev branches. List the tasks, and open one issue for each task on your version control system. Each issue will be solved in a separate branch. Finally, assign one module to one developer — if it seems that working on one module is a two-person job, divide again into two other submodules. This is a relatively complex task, as the output of one module influences the input of another, so be sure to assign them well. 3.2.3 Making the app production ready This includes two things: scaling and maintaining. As said in the disclaimer, I won’t expand on the topic of scaling, as many have written about that, but here is one piece of advice: make the R process running the app do as less as possible, and in particular prevent it from doing what it’s not supposed to do. Which includes: use JavaScript so that the client browser renders things (instead of making R do the work — basic JS is easy to learn), use parallelization and async, and if possible, make the heavy lifting be done outside the R session running the app. Maintainance, on the other, is something to think about from the beginning. It includes being able to ensure that the application will work on the long run, and that new features can be easily implemented. Working on the long run: separate the code with “business logic” (aka the data manipulation and the algorithm, that can work outside the context of the app) from the code building the application. That way, you can write regression tests for these functions to ensure they are stable. Implement new elements: as we are working with modules, it’s easy to insert new elements inside the global application. "],
["stepbystep.html", "Chapter 4 Step by step 4.1 Step 1: Designing 4.2 Step 2: Prototype 4.3 Step 3: Build 4.4 Step 4: Secure 4.5 Step 5: Deploy", " Chapter 4 Step by step 4.1 Step 1: Designing Don’t rush into coding. I know you want to, because it’s what we like to do and what we are good at. But take time to think about the application, take a pen and a piece of paper and draw the app. Talk about it with the people who will use the app, just to decipher what they actually need. Here are for examples questions you can ask: “Who are the end users of the app?” — This will help you know if the end users are tech literate or not, and what they aim to achieve with the app. “How frequently will they use the app?” — The design part of the app you use every day is more crucial than when the app is used once a month. “What level of interactivity do you want, and to what extent is it central?” — People love interactive graphs and like when things automatically sync with each other. Yet these two can make the app slower. “How important is it that the app is fast?” — Should you spend a lot of time optimizing the little things? etc. Asking questions and drawing the app help you have a good idea of what is expected and what you have to do now. 4.2 Step 2: Prototype I like to go “UI first”. For two main reasons: Once the UI is set, there is no “surprise implementation”. Once we agree on what elements there are in the app, there is no sudden “oh the app needs to do that now”. A set UI allows every person involved to know on which part of the app they are working on. So yes, spend time writing a front-end prototype in lorem ipsum. And good news, we’ve got a tool for you: it’s called {shinipsum} — see the next chapter for more information. 4.3 Step 3: Build Now the UI and the features are set, time to work on the backend. Everybody can now work on the implementation of the functions that process the app inputs. 4.4 Step 4: Secure Be sure to include tests all along the building process. Also, secure that your app can be deploy again as is in the future — that means ensuring you’ve got a proper handle on the necessary R version and of the packages versions used to deploy your app. 4.5 Step 5: Deploy Tools for deployment are not the subject of this book, but the one we like to use are Docker &amp; ShinyProxy, and RStudio Connect. "],
["tools.html", "Chapter 5 Tools 5.1 Package 5.2 Git 5.3 Shiny modules 5.4 {shinipsum} and {fakir}: 5.5 CI and testing 5.6 Deploy", " Chapter 5 Tools 5.1 Package Shiny Apps are to be put into a package. Why? Because it allows them to be documented, tested, and can be installed in several environment. 5.2 Git Friends don’t let friends work on a coding project without version control. 5.3 Shiny modules Shiny modules are crucial tools when it comes to building big shiny apps: they allow to collaborate, to split the work into pieces, they facilitate testing, and they allow implementation of new features to be made more easily. 5.4 {shinipsum} and {fakir}: These two tools allow you to prototype a Shiny App and to go “UI first”. Learn more : https://github.com/ThinkR-open/shinipsum https://github.com/ThinkR-open/fakir 5.5 CI and testing Testing is central for making your application survive on the long run. The {testthat} package can be used to test the “business logic” side of your app, while the application features can be tested with packages like {shinytest}, or software like Katalon. 5.6 Deploy Docker, Shiny Proxy, RStudio Connect… Don’t just put your app on the server and let it live. Use tools that are specifically designed for deploying and scaling web applications. "]
]
